# ESPHome dashboard for reterminal e1001 (ESP32-S3) with calendar + poop sensor
#
# Secrets required:
#   wifi_ssid
#   wifi_password
#   api_encryption_key
#   ota_password
#
# Ensure Home Assistant provides sensor.esp_calendar_data with attributes:
#   - entries (JSON array)
#   - todays_day_name
#   - todays_date_month_year

esphome:
  name: dashboard
  friendly_name: Dashboard
  on_boot:
    priority: 600
    then:
      - output.turn_on: bsp_battery_enable

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
  platformio_options:
    platform: espressif32@6.6.0

logger:
  level: DEBUG
  logs:
    display: DEBUG
    json: DEBUG
    component: DEBUG
    homeassistant: DEBUG
    calendar: DEBUG

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: 192.168.1.192

captive_portal:

output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

globals:
  - id: battery_glyph
    type: std::string
    restore_value: no
    initial_value: "\"\\U000F0079\"" # default full battery

sensor:
  - platform: homeassistant
    entity_id: sensor.poop_hut_waste_drawer
    id: poopHutBin
    internal: true

  # display has onboard temp & humidity
  - platform: sht4x
    temperature:
      name: "Temperature"
      id: temp_sensor
    humidity:
      name: "Relative Humidity"
      id: hum_sensor

  # Battery Monitoring
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0 # Voltage divider compensation

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    icon: "mdi:battery"
    device_class: battery
    state_class: measurement
    lambda: "return id(battery_voltage).state;"
    update_interval: 60s
    on_value:
      then:
        - lambda: |-
            int pct = int(x);
            if (pct <= 10)      id(battery_glyph) = "\U000F007A";
            else if (pct <= 20) id(battery_glyph) = "\U000F007B";
            else if (pct <= 30) id(battery_glyph) = "\U000F007C";
            else if (pct <= 40) id(battery_glyph) = "\U000F007D";
            else if (pct <= 50) id(battery_glyph) = "\U000F007E";
            else if (pct <= 60) id(battery_glyph) = "\U000F007F";
            else if (pct <= 70) id(battery_glyph) = "\U000F0080";
            else if (pct <= 80) id(battery_glyph) = "\U000F0081";
            else if (pct <= 90) id(battery_glyph) = "\U000F0082";
            else                id(battery_glyph) = "\U000F0079";
    filters:
      - calibrate_linear:
          - 4.15 -> 100.0
          - 3.96 -> 90.0
          - 3.91 -> 80.0
          - 3.85 -> 70.0
          - 3.80 -> 60.0
          - 3.75 -> 50.0
          - 3.68 -> 40.0
          - 3.58 -> 30.0
          - 3.49 -> 20.0
          - 3.41 -> 10.0
          - 3.30 -> 5.0
          - 3.27 -> 0.0
      - clamp:
          min_value: 0
          max_value: 100

text_sensor:
  # Calendar payload from HA template sensor (attr: entries)
  - platform: homeassistant
    entity_id: sensor.esp_calendar_data
    attribute: entries
    id: calendar_entries_raw
    internal: true
  - platform: homeassistant
    entity_id: sensor.esp_calendar_data
    attribute: todays_day_name
    id: calendar_day_name
    internal: true
  - platform: homeassistant
    entity_id: sensor.esp_calendar_data
    attribute: todays_date_month_year
    id: calendar_date
    internal: true

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true
    id: primary_button
    name: "Primary Button"
    on_press:
      then:
        - lambda: |-
            id(epaper_display).update();

json:

font:
  - file: "gfonts://Inter@700"
    id: font_title
    size: 26
  - file: "gfonts://Inter@600"
    id: font_body
    size: 20
  - file: "gfonts://Inter@500"
    id: font_small
    size: 16
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: font_bat_icon
    size: 24
    glyphs:
      - "\U000F007A" # mdi-battery-10
      - "\U000F007B" # mdi-battery-20
      - "\U000F007C" # mdi-battery-30
      - "\U000F007D" # mdi-battery-40
      - "\U000F007E" # mdi-battery-50
      - "\U000F007F" # mdi-battery-60
      - "\U000F0080" # mdi-battery-70
      - "\U000F0081" # mdi-battery-80
      - "\U000F0082" # mdi-battery-90
      - "\U000F0079" # mdi-battery

time:
  - platform: homeassistant
    id: ha_time

spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9

display:
  - platform: waveshare_epaper
    id: epaper_display
    model: 7.50inv2
    cs_pin: GPIO10
    dc_pin: GPIO11
    reset_pin:
      number: GPIO12
      inverted: false
    busy_pin:
      number: GPIO13
      inverted: true
    update_interval: never
    lambda: |-
      using namespace esphome;
      ESP_LOGD("calendar", "Render start");
      // Force white background with black text
      it.fill(Color::WHITE);
      // Header + poop status
      it.printf(6, 6, id(font_title), Color::BLACK, "Poop in the Hut:");
      if (!isnan(id(poopHutBin).state)) {
        it.printf(6, 38, id(font_title), Color::BLACK, "%.0f%%", id(poopHutBin).state);
      } else {
        it.printf(6, 38, id(font_title), Color::BLACK, "--");
      }

      int y = 78;
      // Calendar heading
      if (!id(calendar_day_name).state.empty() && !id(calendar_date).state.empty()) {
        it.printf(6, y, id(font_body), Color::BLACK, "%s, %s",
                  id(calendar_day_name).state.c_str(),
                  id(calendar_date).state.c_str());
        y += 22;
      } else {
        it.printf(6, y, id(font_body), Color::BLACK, "Calendar");
        y += 22;
      }

      // Parse calendar entries JSON
      auto json_str = id(calendar_entries_raw).state;
      if (json_str.empty()) {
        it.printf(6, y, id(font_small), Color::BLACK, "No calendar data");
        ESP_LOGW("calendar", "No calendar data; raw string empty");
        return;
      }

      ESP_LOGW("calendar", "Calendar JSON len=%d", (int)json_str.size());
      ESP_LOGD("calendar", "Calendar JSON preview: %s", json_str.substr(0, 200).c_str());
      ESP_LOGI("calendar", "Calendar JSON full: %s", json_str.c_str());

      auto doc = json::parse_json(json_str);
      if (!doc.is<JsonArray>() && !doc.is<JsonObject>()) {
        it.printf(6, y, id(font_small), Color::BLACK, "Bad calendar data");
        ESP_LOGW("calendar", "Failed to parse calendar JSON");
        return;
      }

      JsonArray days = doc.as<JsonArray>();
      if (days.isNull()) {
        ESP_LOGW("calendar", "Root is not an array");
        it.printf(6, y, id(font_small), Color::BLACK, "Bad calendar data");
        return;
      }
      ESP_LOGW("calendar", "Days count: %u", days.size());

      int shown = 0;
      int ly = y;
      int day_idx = 0;
      for (JsonObject day : days) {
        if (shown >= 5) break;
        const char *day_name = day["day_name"] | "";
        int day_num = day["day"] | 0;
        ESP_LOGW("calendar", "Day[%d] %s %d", day_idx, day_name, day_num);
        it.printf(6, ly, id(font_small), Color::BLACK, "%s %d", day_name, day_num);
        ly += 16;

        JsonArray other = day["other"];
        ESP_LOGD("calendar", "Day[%d] has %u events", day_idx, other.size());
        for (JsonObject ev : other) {
          if (shown >= 5) break;
          const char *title = ev["summary"] | ev["description"] | "";
          std::string start = ev["start"] | "";
          auto tpos = start.find('T');
          if (tpos != std::string::npos && start.size() >= tpos + 5) {
            start = start.substr(tpos + 1, 5);
          }
          ESP_LOGW("calendar", "Event %s %s", start.c_str(), title);
          it.printf(10, ly, id(font_small), Color::BLACK, "%s", start.c_str());
          ly += 14;
          it.printf(10, ly, id(font_small), Color::BLACK, "%s", title);
          ly += 14;
          shown++;
        }
        day_idx++;
        ly += 6; // small gap between days
      }
